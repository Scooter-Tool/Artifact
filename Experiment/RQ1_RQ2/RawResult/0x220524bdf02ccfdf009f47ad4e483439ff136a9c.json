[
  {
    "contract": "SaleManager",
    "function": "createUser",
    "explanation": "Function comment specifies deploying NFT contract and setting SalesManager, which is missing in implementation.",
    "violated_comment": "/**\n* @dev only deploy nft contract once shareLedger is finalized, then set the SalesManager in the nft equal to this address\n**/",
    "contract_code": "\n=== Implementation of Function createUser(address,uint256) ===\nfunction createUser(address _address, uint _share) external{\r\n        require(msg.sender == owner, 'Only the owner can create users');\r\n        require(_share > 0, 'Share must be greater than zero');//makes it so that owner can not zero out shares after allocated shares is equal to 100\r\n        require(allocatedShare.add(_share) <= 100, 'Total share allocation greater than 100');\r\n        shareLedger[_address] = User({\r\n            claimed: false,\r\n            share: _share\r\n        });\r\n        allocatedShare = allocatedShare.add(_share);\r\n    }\n    \n=== Functions that function createUser internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }",
    "rewritten_code": {
      "createUser": "function createUser(address _address, uint _share) external{\n        require(msg.sender == owner, 'Only the owner can create users');\n        require(_share > 0, 'Share must be greater than zero');\n        require(allocatedShare.add(_share) <= 100, 'Total share allocation greater than 100');\n        shareLedger[_address] = User({\n            claimed: false,\n            share: _share\n        });\n        allocatedShare = allocatedShare.add(_share);\n        if (allocatedShare == 100) {\n            SaleManager newManager = new SaleManager(owner(), address(this));\n            newManager.setSalesManager(address(this));\n            saleManager = payable(address(newManager));\n        }\n    }"
    }
  },
  {
    "contract": "ERC721",
    "function": "tokenURI",
    "explanation": "When base URI is empty and no token URI is set, returns empty instead of token ID.",
    "violated_comment": "Returns the base URI set via {_setBaseURI}. This will be automatically added as a prefix in {tokenURI} to each token's URI, or to the token ID if no specific URI is set for that token ID.",
    "contract_code": "\n=== Implementation of Function tokenURI(uint256) ===\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        string memory base = baseURI();\r\n\r\n        if (bytes(base).length == 0) {\r\n            return _tokenURI;\r\n        }\r\n        if (bytes(_tokenURI).length > 0) {\r\n            return string(abi.encodePacked(base, _tokenURI));\r\n        }\r\n        return string(abi.encodePacked(base, tokenId.toString()));\r\n    }\n    \n=== Functions that function tokenURI internally calls ===\nfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _tokenOwners.contains(tokenId);\r\n    }\nfunction baseURI() public view virtual returns (string memory) {\r\n        return _baseURI;\r\n    }\nfunction toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }",
    "rewritten_code": {
      "function_name": "function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        if (bytes(base).length == 0) {\n            if (bytes(_tokenURI).length == 0) {\n                return tokenId.toString();\n            }\n            return _tokenURI;\n        }\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }"
    }
  }
]