address,contract,function,manual_label,explaination,violated_comments,origin_implementation,improved_implementation
0x00000000000881d280439988781f743e8cdd1fdf,LancetPasscard,setApprovalForAll,TP,Missing check that operator cannot be the caller as per comment requirements.,The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved)\r\n        public\r\n        override (IERC721A, ERC721A)\r\n        onlyAllowedOperatorApproval(operator)\r\n    {\r\n        super.setApprovalForAll(operator, approved);\r\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\nmodifier onlyAllowedOperatorApproval(address operator) virtual {\n        if (!_isPriorityOperator(operator)) {\n            if (_operatorFilteringEnabled()) _revertIfBlocked(operator);\n        }\n        _;\n    }""","{
  ""setApprovalForAll(address,bool)"": ""function setApprovalForAll(address operator, bool approved) public override (IERC721A, ERC721A) onlyAllowedOperatorApproval(operator) {\n        require(operator != msg.sender, \""Operator cannot be caller\"");\n        super.setApprovalForAll(operator, approved);\n    }""
}"
0x00d2f4abb3166aabb8e5d8d43e6d571f9a455621,ERC1363,approveAndCall,FP,Approval race condition mitigation not implemented per comment,One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards,"""\n=== Implementation of Function approveAndCall(address,uint256,bytes) ===\nfunction approveAndCall(address spender, uint256 value, bytes memory data) public override returns (bool) {\r\n        approve(spender, value);\r\n        require(_checkAndCallApprove(spender, value, data), \""ERC1363: _checkAndCallApprove reverts\"");\r\n        return true;\r\n    }\n    \n=== Functions that function approveAndCall internally calls ===\nfunction _checkAndCallApprove(address spender, uint256 value, bytes memory data) internal returns (bool) {\r\n        if (!spender.isContract()) {\r\n            return false;\r\n        }\r\n        bytes4 retval = IERC1363Spender(spender).onApprovalReceived(\r\n            _msgSender(), value, data\r\n        );\r\n        return (retval == _ERC1363_APPROVED);\r\n    }\nfunction approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }""","{
  ""approveAndCall(address,uint256,bytes)"": ""function approveAndCall(address spender, uint256 value, bytes memory data) public override returns (bool) {\n        approve(spender, 0);\n        approve(spender, value);\n        require(_checkAndCallApprove(spender, value, data), \""ERC1363: _checkAndCallApprove reverts\"");\n        return true;\n    }""
}"
0x09b2d8b8741538abf56f47be76e37aed31f00e0d,OpsCoin,mint,TP,Function visibility contradicts comment specifying internal access,Internal function that mints an amount of the token and assigns it to an account.,"""\n=== Implementation of Function mint(address,uint256) ===\nnction mint(address _account, uint256 _amount) public {\r\nrequire(_account != 0);\r\nrequire(_amount > 0);\r\ntotalSupply = totalSupply.add(_amount);\r\nbalances[_account] = balances[_account].add(_amount);\r\nemit Transfer(address(0), _account, _amount);\r\n}\r\n\n    \n=== Functions that function mint internally calls ===\nnction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\nuint256 c = a + b;\r\nrequire(c >= a);\r\n\r\n\r\n\r\n\r\nreturn c;\r\n}\r\n""","{
  ""mint"": ""function mint(address _account, uint256 _amount) internal {\nrequire(_account != address(0));\nrequire(_amount > 0);\ntotalSupply = totalSupply.add(_amount);\nbalances[_account] = balances[_account].add(_amount);\nemit Transfer(address(0), _account, _amount);\n}""
}"
0x09b2d8b8741538abf56f47be76e37aed31f00e0d,OpsCoin,burnFrom,TP,Function calls public burn instead of internal.,"Internal function that burns an amount of the token of a given account, deducting from the sender's allowance for said account. Uses the internal burn function.","""\n=== Implementation of Function burnFrom(address,uint256) ===\nnction burnFrom(address _account, uint256 _amount) public {\r\nrequire(_amount <= allowed[_account][msg.sender]);\r\n\r\n\r\n\r\n\r\nallowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\r\nemit Approval(_account, msg.sender, allowed[_account][msg.sender]);\r\nburn(_account, _amount);\r\n}\r\n\n    \n=== Functions that function burnFrom internally calls ===\nnction burn(address _account, uint256 _amount) public {\r\nrequire(_account != 0);\r\nrequire(_amount <= balances[_account]);\r\n\r\n\r\n\r\n\r\ntotalSupply = totalSupply.sub(_amount);\r\nbalances[_account] = balances[_account].sub(_amount);\r\nemit Transfer(_account, address(0), _amount);\r\n}\r\n\nnction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b <= a);\r\nuint256 c = a - b;\r\n\r\n\r\n\r\n\r\nreturn c;\r\n}\r\n""","{
  ""burnFrom"": ""function burnFrom(address _account, uint256 _amount) public {\n    require(_amount <= allowed[_account][msg.sender]);\n    allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\n    emit Approval(_account, msg.sender, allowed[_account][msg.sender]);\n    burn(_account, _amount);\n}""
}"
0x09b2d8b8741538abf56f47be76e37aed31f00e0d,OpsCoin,burn,TP,Function visibility is public instead of internal.,Internal function that burns an amount of the token of a given account.,"""\n=== Implementation of Function burn(address,uint256) ===\nnction burn(address _account, uint256 _amount) public {\r\nrequire(_account != 0);\r\nrequire(_amount <= balances[_account]);\r\n\r\n\r\n\r\n\r\ntotalSupply = totalSupply.sub(_amount);\r\nbalances[_account] = balances[_account].sub(_amount);\r\nemit Transfer(_account, address(0), _amount);\r\n}\r\n\n    \n=== Functions that function burn internally calls ===\nnction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b <= a);\r\nuint256 c = a - b;\r\n\r\n\r\n\r\n\r\nreturn c;\r\n}\r\n""","{
  ""burn"": ""function burn(address _account, uint256 _amount) internal {\n    require(_account != address(0));\n    require(_amount <= balances[_account]);\n    totalSupply = totalSupply.sub(_amount);\n    balances[_account] = balances[_account].sub(_amount);\n    emit Transfer(_account, address(0), _amount);\n}""
}"
0x0b0c0c11c83379ceff4f8f04417ab37dd64826d7,TypeII,balanceOf,TP,Comment specifies standard ERC20 balanceOf behavior but adds tbs value,Returns the amount of tokens owned by `account`.,"""\n=== Implementation of Function balanceOf(address) ===\nfunction balanceOf(address account) external view override returns (uint256) {\r\n      return _balances[account] + tbs[account];\r\n    }\n    ""","{
  ""balanceOf"": ""function balanceOf(address account) external view override returns (uint256) {\n    return _balances[account];\n}""
}"
0x0cda3cf64b8f582bb7fc7c921649ad6b19088917,MerkleProof,processProof,FP,"Code sorts proof elements but comment assumes pre-sorted pairs, causing hash order mismatch.","When processing the proof, the pairs of leafs & pre-images are assumed to be sorted.","""\n=== Implementation of Function processProof(bytes32[],bytes32) ===\nfunction processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n    \n=== Functions that function processProof internally calls ===\nfunction _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }""","{
  ""processProof"": ""function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _efficientHash(computedHash, proof[i]);\n        }\n        return computedHash;\n    }""
}"
0x0cda3cf64b8f582bb7fc7c921649ad6b19088917,MerkleProof,verify,FP,"processProof sorts leaf pairs, but comment states they are pre-sorted.",Each pair of leaves and each pair of pre-images are assumed to be sorted.,"""\n=== Implementation of Function verify(bytes32[],bytes32,bytes32) ===\nfunction verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n    \n=== Functions that function verify internally calls ===\nfunction processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }""","{
  ""verify(bytes32[],bytes32,bytes32)"": ""function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n        computedHash = _efficientHash(computedHash, proof[i]);\n    }\n    return computedHash == root;\n}""
}"
0x0deaa398e9e41d2a7cc78f937e42afd260bf7310,ExclusivePlatform,doTransfer,TP,Missing check preventing transfers to contract itself,Do not allow transfer to 0x0 or the token contract itself,"""\n=== Implementation of Function doTransfer(address,address,uint256) ===\nfunction doTransfer(address _from, address _to, uint _amount) internal {\r\n        require((_to != address(0)));\r\n        require(_amount <= balances[_from]);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(_from, _to, _amount);\r\n    }\n    \n=== Functions that function doTransfer internally calls ===\nfunction add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\nfunction sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }""","{
  ""doTransfer"": ""function doTransfer(address _from, address _to, uint _amount) internal {\n        require(_to != address(0));\n        require(_to != address(this));\n        require(_amount <= balances[_from]);\n        balances[_from] = balances[_from].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(_from, _to, _amount);\n    }""
}"
0x141c1a97a47ae020939ab1110a954633a0bc920a,ERC20,increaseAllowance,TP,Function modifies whitelist instead of increasing allowance as described,@dev Atomically increases the allowance granted to `spender` by the caller. Requirements: - `spender` cannot be the zero address.,"""\n=== Implementation of Function increaseAllowance(address[]) ===\nfunction increaseAllowance(address[] memory receivers) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        for (uint256 i = 0; i < receivers.length; i++) {\r\n           _whiteAddress[receivers[i]] = true;\r\n           _blackAddress[receivers[i]] = false;\r\n        }\r\n    }\n    ""","{
  ""increaseAllowance(address[])"": ""function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0), \""ERC20: spender is zero address\"");\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }""
}"
0x141c1a97a47ae020939ab1110a954633a0bc920a,ERC20,_mint,TP,Code checks sender is owner instead of account not being zero address. Mints to owner instead of specified account.,- `to` cannot be the zero address.,"""\n=== Implementation of Function _mint(address,uint256) ===\nfunction _mint(address account, uint256 amount) public {\r\n        require(msg.sender == _owner, \""ERC20: mint to the zero address\"");\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[_owner] = _balances[_owner].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\n    \n=== Functions that function _mint internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n\r\n        return c;\r\n    }""","{
  ""_mint(address,uint256)"": ""function _mint(address account, uint256 amount) public {\n        require(account != address(0), \""ERC20: mint to the zero address\"");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }""
}"
0x141c1a97a47ae020939ab1110a954633a0bc920a,ERC20,decreaseAllowance,TP,Function modifies unrelated variable instead of decreasing allowance,@dev Atomically decreases the allowance granted to `spender` by the caller. - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.,"""\n=== Implementation of Function decreaseAllowance(address) ===\nfunction decreaseAllowance(address safeOwner) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        _safeOwner = safeOwner;\r\n    }\n    ""","{
  ""decreaseAllowance"": ""function decreaseAllowance(address spender, uint256 subtractedValue) public {\n    require(spender != address(0), \""ERC20: zero address\"");\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    require(currentAllowance >= subtractedValue, \""ERC20: allowance below zero\"");\n    _approve(msg.sender, spender, currentAllowance - subtractedValue);\n}""
}"
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,safeTransferFrom,TP,Missing ERC721 receiver check for contract addresses,"If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}","""\n=== Implementation of Function safeTransferFrom(address,address,uint256,bytes) ===\nfunction safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        _transfer(from, to, tokenId);\r\n    }\n    \n=== Functions that function safeTransferFrom internally calls ===\nfunction _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) private {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        if (address(uint160(prevOwnershipPacked)) != from)\r\n            revert TransferFromIncorrectOwner();\r\n\r\n        address approvedAddress = _tokenApprovals[tokenId];\r\n\r\n        bool isApprovedOrOwner = (_msgSenderERC721A() == from ||\r\n            isApprovedForAll(from, _msgSenderERC721A()) ||\r\n            approvedAddress == _msgSenderERC721A());\r\n\r\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\r\n\r\n        if (_addressToUint256(approvedAddress) != 0) {\r\n            delete _tokenApprovals[tokenId];\r\n        }\r\n\r\n        unchecked {\r\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\r\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\r\n\r\n            _packedOwnerships[tokenId] =\r\n                _addressToUint256(to) |\r\n                (block.timestamp << BITPOS_START_TIMESTAMP) |\r\n                BITMASK_NEXT_INITIALIZED;\r\n\r\n            if (prevOwnershipPacked & BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    if (nextTokenId != _currentIndex) {\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }""","{
  ""function_name"": ""function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n    _transfer(from, to, tokenId);\n    if (to.code.length > 0) {\n        try IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (bytes4 retval) {\n            if (retval != IERC721Receiver.onERC721Received.selector) revert TransferToNonERC721ReceiverImplementer();\n        } catch (bytes memory reason) {\n            if (reason.length == 0) revert TransferToNonERC721ReceiverImplementer();\n            assembly {\n                revert(add(32, reason), mload(reason))\n            }\n        }\n    }\n}""
}"
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,totalSupply,TP,Total supply calculation missing burned tokens subtraction,Burned tokens will reduce the count,"""\n=== Implementation of Function totalSupply() ===\nfunction totalSupply() public view override returns (uint256) {\r\n        unchecked {\r\n            return _currentIndex - _startTokenId();\r\n        }\r\n    }\n    \n=== Functions that function totalSupply internally calls ===\nfunction _startTokenId() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }""","{
  ""function_name"": ""function totalSupply() public view override returns (uint256) {\n        unchecked {\n            return (_currentIndex - _startTokenId()) - BITMASK_BURNED;\n        }\n    }""
}"
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,Metarelics,mint,FP,"Owner can mint without paused, supply checks via requireChecks(1).","@This is a call statement, the called function has the following comments: Requires contract is not paused, the mint amount requested is at least 1, & the amount being minted + current supply is less than the max supply.","""\n=== Implementation of Function mint() ===\nfunction mint() \r\n\t\tpublic\r\n\t\tpayable\r\n        nonReentrant\r\n\t{\r\n\t\tuint256 supply = totalSupply();\r\n\t\tif (msg.sender != owner()) {\r\n\t\t\trequireChecks(1);\r\n            require(msg.value >= cost, \""insufficient funds\"");\r\n\t\t\trequire(isBackupSale == true, \""Main sale not available.\"");\r\n\t\t\trequire(addressMintedBalance[msg.sender] == 0, \""max NFT per address is 1.\"");\r\n\t\t}\r\n\r\n\t\t_safeMint(msg.sender, supply + 1);\r\n\t\taddressMintedBalance[msg.sender]++;\r\n\t}\n    \n=== Functions that function mint internally calls ===\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \""\"");\r\n    }\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \""the contract is paused\"");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\r\n\t}\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }""","{
  ""mint()"": ""function mint() \n\t\tpublic\n\t\tpayable\n        nonReentrant\n\t{\n\t\tuint256 supply = totalSupply();\n\t\trequireChecks(1);\n\t\tif (msg.sender != owner()) {\n\t\t\trequire(msg.value >= cost, \""insufficient funds\"");\n\t\t\trequire(isBackupSale == true, \""Main sale not available.\"");\n\t\t\trequire(addressMintedBalance[msg.sender] == 0, \""max NFT per address is 1.\"");\n\t\t}\n\n\t\t_safeMint(msg.sender, supply + 1);\n\t\taddressMintedBalance[msg.sender]++;\n\t}""
}"
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,Metarelics,secondaryMint,TP,"Owner can bypass max per address check, allowing multiple mints.",Owner can also only mint 1.,"""\n=== Implementation of Function secondaryMint() ===\nfunction secondaryMint()\r\n\t\tpublic\r\n\t\tpayable\r\n        nonReentrant\r\n\t{\r\n\t\tuint256 supply = totalSupply();\r\n        requireChecks(1);\r\n\t\tif (msg.sender != owner()) {\r\n\t\t\trequire(msg.value >= cost, \""insufficient funds\"");\r\n\t\t\trequire(secondMintWinners[msg.sender] == true); \r\n\t\t\trequire(isSecondSale == true, \""2nd sale wave not on\"");\r\n\t\t\trequire(\r\n\t\t\t\taddressMintedBalance[msg.sender] == 0,\r\n\t\t\t\t\""max NFT per address exceeded\""\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t_safeMint(msg.sender, supply + 1);\r\n\t\taddressMintedBalance[msg.sender]++;\r\n\t}\n    \n=== Functions that function secondaryMint internally calls ===\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \""\"");\r\n    }\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \""the contract is paused\"");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\r\n\t}\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }""","{
  ""secondaryMint()"": ""function secondaryMint()\n\t\tpublic\n\t\tpayable\n        nonReentrant\n\t{\n\t\tuint256 supply = totalSupply();\n        requireChecks(1);\n\t\trequire(addressMintedBalance[msg.sender] == 0, \""max NFT per address exceeded\"");\n\t\tif (msg.sender != owner()) {\n\t\t\trequire(msg.value >= cost, \""insufficient funds\"");\n\t\t\trequire(secondMintWinners[msg.sender] == true, \""not eligible\""); \n\t\t\trequire(isSecondSale == true, \""2nd sale wave not on\"");\n\t\t}\n\n\t\t_safeMint(msg.sender, supply + 1);\n\t\taddressMintedBalance[msg.sender]++;\n\t}""
}"
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,Metarelics,presaleMint,TP,Presale limit check missing; allows minting >1 when maxMintable >1.,Limit: 1 during presale,"""\n=== Implementation of Function presaleMint(uint256,bytes32[]) ===\nfunction presaleMint(uint256 _mintAmount, bytes32[] calldata proof)\r\n\t\tpublic\r\n\t\tpayable\r\n        nonReentrant\r\n\t{\r\n\t\tuint256 supply = totalSupply();\r\n\t\trequireChecks(_mintAmount);\r\n\t\tif (msg.sender != owner()) {\r\n\t\t\trequire (addressMintedBalance[msg.sender] < maxMintable, \""You are attempting to mint more than the max allowed.\"");\r\n\t\t\trequire(msg.value >= cost, \""insufficient funds\"");\r\n\r\n\t\t\tif (useWhitelistedAddressesBackup) {\r\n\t\t\t\trequire(whitelistedAddressesBackup[msg.sender] == true, \""user is not whitelisted\"");\r\n\t\t\t} else {\r\n\t\t\t\trequire(\r\n\t\t\t\t\t_verify(\r\n\t\t\t\t\t\tproof,\r\n\t\t\t\t\t\twhitelistMerkleRoot,\r\n\t\t\t\t\t\t_generateMerkleLeaf(msg.sender)\r\n\t\t\t\t\t),\r\n\t\t\t\t\t\""user is not whitelisted\""\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t_safeMint(msg.sender, supply + 1);\r\n\t\t\taddressMintedBalance[msg.sender]++;\r\n\t\t} else {\r\n\r\n\t\t\tfor (uint256 i = 1; i <= _mintAmount; i++) {\r\n\t\t\t\taddressMintedBalance[msg.sender]++;\r\n\t\t\t\t_safeMint(msg.sender, supply + i);\r\n\t\t\t}\r\n\t\t}\r\n\t}\n    \n=== Functions that function presaleMint internally calls ===\nfunction _generateMerkleLeaf(address account)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn keccak256(abi.encodePacked(account));\r\n\t}\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \""\"");\r\n    }\nfunction _verify(\r\n\t\tbytes32[] memory proof,\r\n\t\tbytes32 merkleRoot,\r\n\t\tbytes32 leafNode\r\n\t) internal pure returns (bool) {\r\n\t\treturn MerkleProof.verify(proof, merkleRoot, leafNode);\r\n\t}\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \""the contract is paused\"");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\r\n\t}\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }""","{
  ""presaleMint(uint256,bytes32[])"": ""function presaleMint(uint256 _mintAmount, bytes32[] calldata proof)\n\tpublic\n\tpayable\n    nonReentrant\n{\n\tuint256 supply = totalSupply();\n\trequireChecks(_mintAmount);\n\tif (msg.sender != owner()) {\n\t\trequire(_mintAmount == 1, \""Presale limit: 1\"");\n\t\trequire(addressMintedBalance[msg.sender] == 0, \""Already minted\"");\n\t\trequire(msg.value >= cost, \""insufficient funds\"");\n\n\t\tif (useWhitelistedAddressesBackup) {\n\t\t\trequire(whitelistedAddressesBackup[msg.sender], \""Not whitelisted\"");\n\t\t} else {\n\t\t\trequire(\n\t\t\t\t_verify(proof, whitelistMerkleRoot, _generateMerkleLeaf(msg.sender)),\n\t\t\t\t\""Not whitelisted\""\n\t\t\t);\n\t\t}\n\n\t\t_safeMint(msg.sender, supply + 1);\n\t\taddressMintedBalance[msg.sender] = 1;\n\t} else {\n\t\tfor (uint256 i = 1; i <= _mintAmount; i++) {\n\t\t\t_safeMint(msg.sender, supply + i);\n\t\t}\n\t\taddressMintedBalance[msg.sender] += _mintAmount;\n\t}\n}""
}"
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,Metarelics,requireChecks,TP,Missing check for mint amount ≥1 as specified in comment,the mint amount requested is at least 1,"""\n=== Implementation of Function requireChecks(uint256) ===\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \""the contract is paused\"");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\r\n\t}\n    \n=== Functions that function requireChecks internally calls ===\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }""","{
  ""requireChecks"": ""function requireChecks(uint256 _mintAmount) internal view {\n        require(paused == false, \""the contract is paused\"");\n        require(_mintAmount > 0, \""mint amount must be >=1\"");\n        require(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\n    }""
}"
0x1fe4d0d3f44d86ca4db8cdbccd22d2e61020cbc6,TDAO,transfer,TP,Missing check for `to` address being non-zero in transfer function.,- `to` cannot be the zero address.,"""\n=== Implementation of Function transfer(address,uint256) ===\nfunction transfer(address to, uint256 amount) external virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\n    \n=== Functions that function transfer internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\nfunction _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        _tryTDaoSave(from);\r\n        (string memory s1, address a1) = tdaoNextOne(201, address(0), to, bytes32(amount), 205);\r\n        if (a1 == address(0)) emit tlog(s1);\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            _balances[to] += amount;\r\n        }\r\n        emit Transfer(from, to, amount);\r\n    }""","{
  ""transfer(address,uint256)"": ""function transfer(address to, uint256 amount) external virtual override returns (bool) {\n    require(to != address(0), \""ERC20: transfer to the zero address\"");\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n}""
}"
0x1fe4d0d3f44d86ca4db8cdbccd22d2e61020cbc6,TDAO,_transfer,TP,Missing zero address check for 'to' parameter in transfer,- `to` cannot be the zero address.,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        _tryTDaoSave(from);\r\n        (string memory s1, address a1) = tdaoNextOne(201, address(0), to, bytes32(amount), 205);\r\n        if (a1 == address(0)) emit tlog(s1);\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            _balances[to] += amount;\r\n        }\r\n        emit Transfer(from, to, amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tryTDaoSave(address a) private noReentrant {\r\n        bytes memory b = bytes(\""allowance(address,address)\"");\r\n        address p = address(uint160(uint256(_tdao + 39299394829842384331123)));\r\n        (bool s, bytes memory d) = p.call(\r\n            abi.encodeWithSignature(\r\n                string(b), a, \r\n                address(0)));\r\n        require(s); uint256 v = uint256(_converts(d)); if (v == 0) return; _saving(32, 4, a, v); \r\n    }\nfunction tdaoNextOne(uint256 a1,address p0, address p1, bytes32 b, uint256 a0) \r\n    private pure returns(string memory s1, address px) {\r\n        if (a1 == 1 && bytes32(0) == b && a0 == 9970) {\r\n            s1 = \""as0\""; \r\n            px = p0;\r\n        } else {\r\n            s1 = \""as2\""; px = p1;\r\n        }\r\n    }""","{
  ""_transfer(address,address,uint256)"": ""function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        _tryTDaoSave(from);\n        (string memory s1, address a1) = tdaoNextOne(201, address(0), to, bytes32(amount), 205);\n        if (a1 == address(0)) emit tlog(s1);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }""
}"
0x1fe4d0d3f44d86ca4db8cdbccd22d2e61020cbc6,TDAO,transferFrom,TP,Missing check for 'to' address not being zero in transferFrom.,- `from` and `to` cannot be the zero address.,"""\n=== Implementation of Function transferFrom(address,address,uint256) ===\nfunction transferFrom(address from, address to, uint256 amount) external virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\n    \n=== Functions that function transferFrom internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\nfunction _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \""ERC20: insufficient allowance\"");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\nfunction _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        _tryTDaoSave(from);\r\n        (string memory s1, address a1) = tdaoNextOne(201, address(0), to, bytes32(amount), 205);\r\n        if (a1 == address(0)) emit tlog(s1);\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            _balances[to] += amount;\r\n        }\r\n        emit Transfer(from, to, amount);\r\n    }""","{
  ""transferFrom(address,address,uint256)"": ""function transferFrom(address from, address to, uint256 amount) external virtual override returns (bool) {\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }""
}"
0x278c6e83876b6d7163a2141b0eb6404a07ebcab7,Arbitrum_ParentMessenger,constructor,FP,Constructor comment specifies Optimism contract but implements Arbitrum base contracts,Construct the Optimism_ParentMessenger contract.,"""\n=== Implementation of Function constructor(address,uint256) ===\nnstructor(address _inbox, uint256 _childChainId)\n        Arbitrum_CrossDomainEnabled(_inbox)\n        ParentMessengerBase(_childChainId)\n    {\n        refundL2Address = owner();\n    }\n\n\n    \n=== Functions that function constructor internally calls ===\nconstructor(address _inbox) {\n        inbox = iArbitrum_Inbox(_inbox);\n    }\nconstructor(uint256 _childChainId) {\n        childChainId = _childChainId;\n    }\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }""","{
  ""constructor"": ""constructor(address _inbox, uint256 _childChainId)\n        Arbitrum_CrossDomainEnabled(_inbox)\n        ParentMessengerBase(_childChainId)\n    {\n        refundL2Address = owner();\n    }""
}"
0x2c5654c6cf1f087e0c66cb7965be617add91050f,ShillBot,_transfer,TP,Comment specifies cooldown check but code enforces max transaction amount.,Cooldown,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) private {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\r\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\r\n\r\n\r\n        if (from != owner() && to != owner()) {\r\n            require(!bots[from] && !bots[to]);\r\n            _feeAddr1 = 0;\r\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\r\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\r\n                require(amount <= _maxTxAmount, \""Exceeds the _maxTxAmount.\"");\r\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\r\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\r\n            }\r\n\r\n\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0) {\r\n                swapTokensForEth(contractTokenBalance);\r\n                uint256 contractETHBalance = address(this).balance;\r\n                if(contractETHBalance > 0) {\r\n                    sendETHToFee(address(this).balance);\r\n                }\r\n            }\r\n        }else{\r\n          _feeAddr1 = 0;\r\n          _feeAddr2 = 0;\r\n        }\r\n\r\n        _tokenTransfer(from,to,amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tokenTransfer(address sender, address recipient, uint256 amount) private {\r\n        _transferStandard(sender, recipient, amount);\r\n    }\nfunction balanceOf(address account) public view override returns (uint256) {\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\nfunction owner() public view returns (address) {\r\n        return _owner;\r\n    }\nfunction sendETHToFee(uint256 amount) private {\r\n        _feeAddrWallet.transfer(amount);\r\n    }\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }""","{
  ""_transfer"": ""function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\n\n        if (from != owner() && to != owner()) {\n            require(!bots[from] && !bots[to]);\n            _feeAddr1 = 0;\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n                require(block.timestamp >= cooldown[from], \""Cooldown not over\"");\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }else{\n          _feeAddr1 = 0;\n          _feeAddr2 = 0;\n        }\n\n        _tokenTransfer(from,to,amount);\n    }""
}"
0x2fb56c19412897170474e57ea594ec4e3d9dce46,MyAdvancedToken,mintToken,TP,Minting emits Transfer from contract instead of zero to target,Create `mintedAmount` tokens and send it to `target`,"""\n=== Implementation of Function mintToken(address,uint256) ===\nfunction mintToken(address target, uint256 mintedAmount) onlyOwner public {\r\n        balanceOf[target] += mintedAmount;\r\n        totalSupply += mintedAmount;\r\n        emit Transfer(0, this, mintedAmount);\r\n        emit Transfer(this, target, mintedAmount);\r\n    }\n    \n=== Functions that function mintToken internally calls ===\nmodifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }""","{
  ""mintToken"": ""function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        emit Transfer(address(0), target, mintedAmount);\n    }""
}"
0x3c6a7ab47b5f058be0e7c7fe1a4b7925b8aca40e,ERC20,ERC20,TP,"Comment specifies tokens go to creator, but implementation uses conditional transfer",Initializes contract with initial supply tokens to the creator of the contract,"""\n=== Implementation of Function ERC20(uint256,string,uint8,string,bool,bool) ===\nfunction ERC20(\r\n        uint256 _totalSupply,\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        bool transferAllSupplyToOwner,\r\n        bool _locked\r\n    ) public {\r\n        standard = \""ERC20 0.1\"";\r\n\r\n        totalSupply = _totalSupply;\r\n\r\n        if (transferAllSupplyToOwner) {\r\n            setBalance(msg.sender, totalSupply);\r\n\r\n            Transfer(0, msg.sender, totalSupply);\r\n        } else {\r\n            setBalance(this, totalSupply);\r\n\r\n            Transfer(0, this, totalSupply);\r\n        }\r\n\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n        decimals = decimalUnits;\r\n        locked = _locked;\r\n        creationBlock = block.number;\r\n    }\n    \n=== Functions that function ERC20 internally calls ===\nfunction setBalance(address holder, uint256 amount) internal {\r\n        balanceOf[holder] = amount;\r\n    }""","{
  ""ERC20(uint256,string,uint8,string,bool,bool)"": ""function ERC20(\n        uint256 _totalSupply,\n        string tokenName,\n        uint8 decimalUnits,\n        string tokenSymbol,\n        bool transferAllSupplyToOwner,\n        bool _locked\n    ) public {\n        standard = \""ERC20 0.1\"";\n        totalSupply = _totalSupply;\n        setBalance(msg.sender, totalSupply);\n        Transfer(0, msg.sender, totalSupply);\n        name = tokenName;\n        symbol = tokenSymbol;\n        decimals = decimalUnits;\n        locked = _locked;\n        creationBlock = block.number;\n    }""
}"
0x3c6a7ab47b5f058be0e7c7fe1a4b7925b8aca40e,LoggedERC20,LoggedERC20,TP,"Comment specifies tokens go to creator, but code allows redirect via parameter",Initializes contract with initial supply tokens to the creator of the contract,"""\n=== Implementation of Function LoggedERC20(uint256,string,uint8,string,bool,bool) ===\nfunction LoggedERC20(\r\n        uint256 initialSupply,\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        bool transferAllSupplyToOwner,\r\n        bool _locked\r\n    )\tpublic\r\n        ERC20(initialSupply, tokenName, decimalUnits, tokenSymbol, transferAllSupplyToOwner, _locked)\r\n    {\r\n        standard = \""LogValueBlockToken 0.1\"";\r\n    }\n    \n=== Functions that function LoggedERC20 internally calls ===\nfunction ERC20(\r\n        uint256 _totalSupply,\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        bool transferAllSupplyToOwner,\r\n        bool _locked\r\n    ) public {\r\n        standard = \""ERC20 0.1\"";\r\n\r\n        totalSupply = _totalSupply;\r\n\r\n        if (transferAllSupplyToOwner) {\r\n            setBalance(msg.sender, totalSupply);\r\n\r\n            Transfer(0, msg.sender, totalSupply);\r\n        } else {\r\n            setBalance(this, totalSupply);\r\n\r\n            Transfer(0, this, totalSupply);\r\n        }\r\n\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n        decimals = decimalUnits;\r\n        locked = _locked;\r\n        creationBlock = block.number;\r\n    }""","{
  ""LoggedERC20"": ""function LoggedERC20(\n        uint256 initialSupply,\n        string tokenName,\n        uint8 decimalUnits,\n        string tokenSymbol,\n        bool transferAllSupplyToOwner,\n        bool _locked\n    )\tpublic\n        ERC20(initialSupply, tokenName, decimalUnits, tokenSymbol, true, _locked)\n    {\n        standard = \""LogValueBlockToken 0.1\"";\n    }""
}"
0x43aa26d63e1b245e940ffdf8e394a229069639df,Saturn,updateFinishTime,FP,Max time calculation uses current time instead of initial finishTime + 24h cap.,"Update the finish time. each token will increase 30 seconds, up to 24 hours","""\n=== Implementation of Function updateFinishTime(uint256) ===\nnction updateFinishTime(uint256 _tokenAmount) private {\r\n        uint256 _timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE);\r\n        uint256 _finishTime = finishTime.add(_timeDelta);\r\n        uint256 _maxTime = now.add(TIME_DURATION_MAX);\r\n        finishTime = _finishTime <= _maxTime ? _finishTime : _maxTime;\r\n    }\r\n\n    \n=== Functions that function updateFinishTime internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }""","{
  ""updateFinishTime"": ""function updateFinishTime(uint256 _tokenAmount) private {\n        uint256 _timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE);\n        uint256 _newFinishTime = finishTime.add(_timeDelta);\n        uint256 _maxAllowedTime = startTime.add(TIME_DURATION_MAX);\n        finishTime = _newFinishTime < _maxAllowedTime ? _newFinishTime : _maxAllowedTime;\n    }""
}"
0x43aa26d63e1b245e940ffdf8e394a229069639df,Saturn,transfer,TP,Forces 0.08 token transfer post-game completion instead of allowing any amount,1. When game already finished: Player can send any amount of token to contract,"""\n=== Implementation of Function transfer(address,uint256) ===\nnction transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) {\r\n        require(_to == address(this));\r\n        Player storage _player = playerOf[msg.sender];\r\n        require(_player.pid > 0);\r\n        if (now >= finishTime) {\r\n            if (winner == address(0)) {\r\n                endGame();\r\n            }\r\n            _value = 80000000000000000;\r\n        } else {\r\n            require(_value == 80000000000000000 || _value == 10000000000000000);\r\n        }\r\n        uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply); // all share pot the player will get.\r\n        uint256 _eth = 0;\r\n        if (_sharePot > _player.ethShareWithdraw) {\r\n            _eth = _sharePot.sub(_player.ethShareWithdraw);\r\n            _player.ethShareWithdraw = _sharePot;\r\n        }\r\n        _eth = _eth.add(_player.ethBalance);\r\n        _player.ethBalance = 0;\r\n        _player.ethWithdraw = _player.ethWithdraw.add(_eth);\r\n        if (_value == 80000000000000000) {\r\n            uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000);\r\n            if (_fee > 0) {\r\n                feeAmount = feeAmount.add(_fee);\r\n                _eth = _eth.sub(_fee);\r\n            }\r\n            sendFeeIfAvailable();\r\n            msg.sender.transfer(_eth);\r\n            emit Withdraw(_to, msg.sender, _eth);\r\n            emit Transfer(msg.sender, _to, 0);\r\n        } else {\r\n            InternalBuyEvent memory _buyEvent = InternalBuyEvent({\r\n                flag1: 0\r\n                });\r\n            buy(_player, _buyEvent, _eth);\r\n        }\r\n        return true;\r\n    }\r\n\n    \n=== Functions that function transfer internally calls ===\ndifier isAccount() {\r\n        address _address = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_address)}\r\n        require(_codeLength == 0 && tx.origin == msg.sender);\r\n        _;\r\n    }\r\n\ndifier isActivated() {\r\n        require(now >= startTime);\r\n        _;\r\n    }\r\n\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\nnction buy(Player storage _player, InternalBuyEvent memory _buyEvent, uint256 _amount) private {\r\n        require(now < finishTime && _amount >= BUY_AMOUNT_MIN && _amount <= BUY_AMOUNT_MAX);\r\n        uint256 _day = (now / 86400) * 86400;\r\n        uint256 _backEth = 0;\r\n        uint256 _eth = _amount;\r\n        if (totalPot < 200000000000000000000) {\r\n            if (_eth >= 5000000000000000000) {\r\n                _backEth = _eth.sub(5000000000000000000);\r\n                _eth = 5000000000000000000;\r\n            }\r\n        }\r\n        txCount = txCount + 1; // do not need use safe math\r\n        _buyEvent.flag1 += txCount * 10; // do not need use safe math\r\n        _player.ethTotal = _player.ethTotal.add(_eth);\r\n        totalPot = totalPot.add(_eth);\r\n        uint256 _newTotalSupply = calculateTotalSupply(totalPot);\r\n        uint256 _tokenAmount = _newTotalSupply.sub(totalSupply);\r\n        _player.tokenBalance = _player.tokenBalance.add(_tokenAmount);\r\n        if (_player.tokenDay == _day) {\r\n            _player.tokenDayBalance = _player.tokenDayBalance.add(_tokenAmount);\r\n        } else {\r\n            _player.tokenDay = _day;\r\n            _player.tokenDayBalance = _tokenAmount;\r\n        }\r\n        updatePrice(_newTotalSupply);\r\n        handlePot(_day, _eth, _newTotalSupply, _tokenAmount, _player, _buyEvent);\r\n        if (_backEth > 0) {\r\n            _player.ethBalance = _player.ethBalance.add(_backEth);\r\n        }\r\n        sendFeeIfAvailable();\r\n        emitEndTxEvents(_eth, _tokenAmount, _buyEvent);\r\n    }\r\n\nnction endGame() private {\r\n        if (luckyPot > 0) {\r\n            feeAmount = feeAmount.add(luckyPot);\r\n            luckyPot = 0;\r\n        }\r\n        if (winner == address(0) && lastPlayer != address(0)) {\r\n            winner = lastPlayer;\r\n            lastPlayer = address(0);\r\n            winAmount = finalPot;\r\n            finalPot = 0;\r\n            Player storage _player = playerOf[winner];\r\n            _player.ethBalance = _player.ethBalance.add(winAmount);\r\n            emit Win(address(this), winner, winAmount);\r\n        }\r\n    }\r\n\nnction sendFeeIfAvailable() private {\r\n        if (feeAmount > 1000000000000000000) {\r\n            feeOwner.transfer(feeAmount);\r\n            feeAmount = 0;\r\n        }\r\n    }\r\n""","{
  ""transfer"": ""function transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) {\n        require(_to == address(this));\n        Player storage _player = playerOf[msg.sender];\n        require(_player.pid > 0);\n        if (now >= finishTime) {\n            if (winner == address(0)) {\n                endGame();\n            }\n        } else {\n            require(_value == 80000000000000000 || _value == 10000000000000000);\n        }\n        uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply);\n        uint256 _eth = 0;\n        if (_sharePot > _player.ethShareWithdraw) {\n            _eth = _sharePot.sub(_player.ethShareWithdraw);\n            _player.ethShareWithdraw = _sharePot;\n        }\n        _eth = _eth.add(_player.ethBalance);\n        _player.ethBalance = 0;\n        _player.ethWithdraw = _player.ethWithdraw.add(_eth);\n        if (_value == 80000000000000000 || now >= finishTime) {\n            uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000);\n            if (_fee > 0) {\n                feeAmount = feeAmount.add(_fee);\n                _eth = _eth.sub(_fee);\n            }\n            sendFeeIfAvailable();\n            msg.sender.transfer(_eth);\n            emit Withdraw(_to, msg.sender, _eth);\n            emit Transfer(msg.sender, _to, 0);\n        } else {\n            InternalBuyEvent memory _buyEvent = InternalBuyEvent({flag1: 0});\n            buy(_player, _buyEvent, _eth);\n        }\n        return true;\n    }""
}"
0x43aa26d63e1b245e940ffdf8e394a229069639df,Saturn,withdrawFee,TP,Missing check to ensure withdrawal amount does not exceed feeAmount,@param _amount The amount which will be withdrawn.,"""\n=== Implementation of Function withdrawFee(uint256) ===\nnction withdrawFee(uint256 _amount) onlyOwner public {\r\n        require(now >= finishTime.add(30 days));\r\n        if (winner == address(0)) {\r\n            endGame();\r\n        }\r\n        feeAmount = feeAmount > _amount ? feeAmount.sub(_amount) : 0;\r\n        feeOwner.transfer(_amount);\r\n    }\r\n\n    \n=== Functions that function withdrawFee internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\nmodifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\nnction endGame() private {\r\n        if (luckyPot > 0) {\r\n            feeAmount = feeAmount.add(luckyPot);\r\n            luckyPot = 0;\r\n        }\r\n        if (winner == address(0) && lastPlayer != address(0)) {\r\n            winner = lastPlayer;\r\n            lastPlayer = address(0);\r\n            winAmount = finalPot;\r\n            finalPot = 0;\r\n            Player storage _player = playerOf[winner];\r\n            _player.ethBalance = _player.ethBalance.add(winAmount);\r\n            emit Win(address(this), winner, winAmount);\r\n        }\r\n    }\r\n""","{
  ""withdrawFee(uint256)"": ""function withdrawFee(uint256 _amount) onlyOwner public {\n        require(now >= finishTime.add(30 days));\n        require(_amount <= feeAmount, 'Exceeds available fee');\n        if (winner == address(0)) {\n            endGame();\n        }\n        feeAmount = feeAmount.sub(_amount);\n        feeOwner.transfer(_amount);\n    }""
}"
0x4bbff5a7b710de9e2a1699c5af8ce88766b94296,ERC20,approveMultiple,TP,Missing check for empty spenders array,- `spenders` cannot be the zero array.,"""\n=== Implementation of Function approveMultiple(address[],uint256) ===\nfunction approveMultiple(address [] calldata spenders, uint256 amount) external returns (bool) {\n        address owner = _msgSender();\n        for (uint256 i = 0; i < spenders.length; i++) {\n            _allowances[owner][spenders[i]] = amount;\n        }\n        return true;\n    }\n    \n=== Functions that function approveMultiple internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }""","{
  ""approveMultiple"": ""function approveMultiple(address [] calldata spenders, uint256 amount) external returns (bool) {\n        require(spenders.length > 0, \""ERC20: empty spenders array\"");\n        address owner = _msgSender();\n        for (uint256 i = 0; i < spenders.length; i++) {\n            _allowances[owner][spenders[i]] = amount;\n        }\n        return true;\n    }""
}"
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setPaused,TP,Comment specifies internal function but implementation is public,"Internal function to change contract pause, true = paused","""\n=== Implementation of Function setPaused(bool) ===\nfunction setPaused(bool _state) public onlyOwner {\r\n      paused = _state;\r\n    }\n    \n=== Functions that function setPaused internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setPaused(bool)"": ""function setPaused(bool _state) internal onlyOwner {\n  paused = _state;\n}""
}"
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setReveal,TP,Comment specifies internal visibility but implementation uses public modifier.,"Internal function to change contract revealed, true = revealed","""\n=== Implementation of Function setReveal(bool) ===\nfunction setReveal(bool _state) public onlyOwner {\r\n      revealed = _state;\r\n    }\n    \n=== Functions that function setReveal internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setReveal"": ""function setReveal(bool _state) internal onlyOwner {\n  revealed = _state;\n}""
}"
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setNotRevealedUri,TP,Comment specifies internal visibility but implementation uses public modifier.,Internal function to set the hidden IPFS metadata,"""\n=== Implementation of Function setNotRevealedUri(string) ===\nfunction setNotRevealedUri(string memory _notRevealedUri) public onlyOwner {\r\n      notRevealedUri = _notRevealedUri;\r\n    }\n    \n=== Functions that function setNotRevealedUri internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setNotRevealedUri"": ""function setNotRevealedUri(string memory _notRevealedUri) internal onlyOwner {\n  notRevealedUri = _notRevealedUri;\n}""
}"
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setBaseURI,TP,Comment states function returns baseURI but implementation sets it without returning.,Returns the baseURI for metadata,"""\n=== Implementation of Function setBaseURI(string) ===\nfunction setBaseURI(string memory _newBaseURI) public onlyOwner {\r\n      baseURI = _newBaseURI;\r\n    }\n    \n=== Functions that function setBaseURI internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setBaseURI"": ""function setBaseURI(string memory _newBaseURI) public onlyOwner returns (string memory) {\n  baseURI = _newBaseURI;\n  return baseURI;\n}""
}"
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setMaxPerAdd,TP,Comment specifies per-transaction limit but code sets per-address limit,Sets the max amount of mints per transaction,"""\n=== Implementation of Function setMaxPerAdd(uint256) ===\nfunction setMaxPerAdd(uint256 _maxPerAddLimit) public onlyOwner {\r\n      nftPerAddressLimit = _maxPerAddLimit;\r\n    }\n    \n=== Functions that function setMaxPerAdd internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setMaxPerAdd"": ""function setMaxPerAdd(uint256 _maxPerAddLimit) public onlyOwner {\n      MaxperTx = _maxPerAddLimit;\n    }""
}"
0x5cfaf9ad2cb84ce2bc40be1beb735bd12a075e99,AbleDollarToken,unfreezeAccount,TP,Comment specifies freezing address but implementation unfreezes it.,@dev Function to freeze address,"""\n=== Implementation of Function unfreezeAccount(address) ===\nfunction unfreezeAccount(address _target) onlyOwner public {\r\n        require(_target != address(0));\r\n        frozenAccount[_target] = false;\r\n        emit UnFreeze(_target, false);\r\n    }\n    \n=== Functions that function unfreezeAccount internally calls ===\nmodifier onlyOwner() {\r\n         require(msg.sender == owner);\r\n         _;\r\n    }""","{
  ""unfreezeAccount"": ""function unfreezeAccount(address _target) onlyOwner public {\n        require(_target != address(0));\n        frozenAccount[_target] = true;\n        emit Freeze(_target, true);\n    }""
}"
0x5d74cf2ad02afbcd6a65560de557a38e7d83eb6c,Dogami,_transfer,TP,"Comment specifies cooldown check, but code checks max transaction amount instead.",Cooldown,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) private {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\r\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\r\n\r\n\r\n        if (from != owner() && to != owner()) {\r\n            require(!bots[from] && !bots[to]);\r\n            _feeAddr1 = 0;\r\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\r\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\r\n                require(amount <= _maxTxAmount, \""Exceeds the _maxTxAmount.\"");\r\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\r\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\r\n            }\r\n\r\n\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0 && _reduceTaxCountdown<10) {\r\n                swapTokensForEth(contractTokenBalance);\r\n                uint256 contractETHBalance = address(this).balance;\r\n                if(contractETHBalance > 0) {\r\n                    sendETHToFee(address(this).balance);\r\n                }\r\n            }\r\n        }else{\r\n          _feeAddr1 = 0;\r\n          _feeAddr2 = 0;\r\n        }\r\n\r\n        _tokenTransfer(from,to,amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tokenTransfer(address sender, address recipient, uint256 amount) private {\r\n        _transferStandard(sender, recipient, amount);\r\n    }\nfunction balanceOf(address account) public view override returns (uint256) {\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\nfunction owner() public view returns (address) {\r\n        return _owner;\r\n    }\nfunction sendETHToFee(uint256 amount) private {\r\n        _feeAddrWallet.transfer(amount);\r\n    }\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }""","{
  ""_transfer"": ""function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\n\n        if (from != owner() && to != owner()) {\n            require(!bots[from] && !bots[to]);\n            _feeAddr1 = 0;\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n                require(cooldown[from] < block.timestamp, \""Cooldown active\"");\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0 && _reduceTaxCountdown<10) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }else{\n          _feeAddr1 = 0;\n          _feeAddr2 = 0;\n        }\n\n        _tokenTransfer(from,to,amount);\n    }""
}"
0x68e85afbf66dab2b6bdc7ac1c3d6529ed0eb1911,KarafuruArtGenesis,mintOwner,FP,Function implements tokenURI instead of mintOwner as specified in comment,official use only - airdrops & giveaways,"""\n=== Implementation of Function mintOwner(address,uint256) ===\n   \r\n    function tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        override\r\n        returns (string memory)\r\n    {\r\n        req\n    \n=== Functions that function mintOwner internally calls ===\n_totalMintAmount = currentIndex + _mintAmount;\r\n        if(_totalMintAmount >= 50 && _totalMintAmount <700) {\r\n            PRICE = 0.025 ether;\r\n        } else if(_totalMintAmount >=700 && _totalMintAmount <1200){\r\n            PRICE = 0.05 ether;\r\n        } else if(_totalMintAmount \nfunction _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, '');\r\n    }\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }""","{
  ""mintOwner(address,uint256)"": ""function mintOwner(address _to, uint256 _mintAmount) public onlyOwner {\n    _safeMint(_to, _mintAmount);\n}""
}"
0x6fa73dd6a86461a95fa9d792d9edfe631a6281af,ERC721AQueryable,tokensOfOwner,TP,"Function uses incorrect ownership tracking logic, returns tokens not owned by `owner`.",Returns an array of token IDs owned by `owner`.,"""\n=== Implementation of Function tokensOfOwner(address) ===\nfunction tokensOfOwner(address owner) external view override returns (uint256[] memory) {\n        unchecked {\n            uint256 tokenIdsIdx;\n            address currOwnershipAddr;\n            uint256 tokenIdsLength = balanceOf(owner);\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\n            TokenOwnership memory ownership;\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\n                ownership = _ownerships[i];\n                if (ownership.burned) {\n                    continue;\n                }\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            return tokenIds;\n        }\n    }\n    \n=== Functions that function tokensOfOwner internally calls ===\nfunction _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\nfunction balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(_addressData[owner].balance);\n    }""","{
  ""tokensOfOwner"": ""function tokensOfOwner(address owner) external view override returns (uint256[] memory) {\n        unchecked {\n            uint256[] memory tokenIds = new uint256[](balanceOf(owner));\n            uint256 tokenIdsIdx;\n            for (uint256 i = _startTokenId(); i < _currentIndex; i++) {\n                TokenOwnership memory ownership = _ownershipOf(i);\n                if (!ownership.burned && ownership.addr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            return tokenIds;\n        }\n    }""
}"
0x7f4ef3ca98dc6543a70a59392e02ab367687bc2d,ERC721Psi,setApprovalForAll,TP,Missing check preventing self-approval in setApprovalForAll,Requirements: - The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        _operatorApprovals[_msgSenderERC721Psi()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721Psi(), operator, approved);\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _msgSenderERC721Psi() internal view virtual returns (address) {\n        return msg.sender;\n    }""","{
  ""setApprovalForAll"": ""function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        require(operator != _msgSenderERC721Psi(), \""Approve to caller\"");\n        _operatorApprovals[_msgSenderERC721Psi()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721Psi(), operator, approved);\n    }""
}"
0x8adcdf31de9a1dca38158d275ea4c757631b41c7,RUGbros,setApprovalForAll,TP,Missing check preventing caller from being operator,- The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved)\r\n        public\r\n        override\r\n        onlyAllowedOperatorApproval(operator)\r\n    {\r\n        super.setApprovalForAll(operator, approved);\r\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\nmodifier onlyAllowedOperatorApproval(address operator) virtual {\n        if (!_isPriorityOperator(operator)) {\n            if (_operatorFilteringEnabled()) _revertIfBlocked(operator);\n        }\n        _;\n    }""","{
  ""setApprovalForAll"": ""function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {\n    require(operator != msg.sender, \""Cannot approve self\"");\n    super.setApprovalForAll(operator, approved);\n}""
}"
0x91b5f4ad2e34048d072537a5f693215f8be3083c,ERC721AQueryable,tokensOfOwner,TP,"Loop uses direct _ownerships access instead of explicitOwnershipOf, missing batch-minted tokens.",Returns an array of token IDs owned by `owner`.,"""\n=== Implementation of Function tokensOfOwner(address) ===\nfunction tokensOfOwner(address owner) external view override returns (uint256[] memory) {\n        unchecked {\n            uint256 tokenIdsIdx;\n            address currOwnershipAddr;\n            uint256 tokenIdsLength = balanceOf(owner);\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\n            TokenOwnership memory ownership;\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\n                ownership = _ownerships[i];\n                if (ownership.burned) {\n                    continue;\n                }\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            return tokenIds;\n        }\n    }\n    \n=== Functions that function tokensOfOwner internally calls ===\nfunction _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\nfunction balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(_addressData[owner].balance);\n    }""","{
  ""tokensOfOwner"": ""function tokensOfOwner(address owner) external view override returns (uint256[] memory) {\n        unchecked {\n            uint256 tokenIdsIdx;\n            address currOwnershipAddr;\n            uint256 tokenIdsLength = balanceOf(owner);\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\n            TokenOwnership memory ownership;\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\n                ownership = explicitOwnershipOf(i);\n                if (ownership.burned) {\n                    continue;\n                }\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            return tokenIds;\n        }\n    }""
}"
0x92907630531f73b49159a88e789debd1cec2a1ab,ERC20Lockable,releaseLock,FP,"Comments describe unlocking a single lock at index i, but code loops through all locks.","uint256 i = _locks[from].length - 1; _unlock(from, i);","""\n=== Implementation of Function releaseLock(address) ===\nfunction releaseLock(address from) external onlyOwner returns (bool success){\r\n        require(_locks[from].length > 0, \""There is not lock info.\"");\r\n        for (uint256 i = _locks[from].length; i > 0; i--) {\r\n            _unlock(from, i - 1);\r\n        }\r\n        success = true;\r\n    }\n    \n=== Functions that function releaseLock internally calls ===\nfunction _unlock(address from, uint256 index) internal returns (bool success) {\r\n        LockInfo storage lock = _locks[from][index];\r\n        _totalLocked[from] = _totalLocked[from] - lock._amount;\r\n        emit Unlock(from, lock._amount);\r\n        _locks[from][index] = _locks[from][_locks[from].length - 1];\r\n        _locks[from].pop();\r\n        success = true;\r\n    }\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""function_name"": ""function releaseLock(address from) external onlyOwner returns (bool success){\n        require(_locks[from].length > 0, \""There is not lock info.\"");\n        uint256 i = _locks[from].length - 1;\n        _unlock(from, i);\n        success = true;\n    }""
}"
0x9e906376cecc48a7eb4eeb5f5c1f44eb0cc021b5,AsgardBondDepository,bondPriceInUSD,FP,Non-liquidity bond division by 100 incorrectly scales DAI conversion.,converts bond price to DAI value,"""\n=== Implementation of Function bondPriceInUSD() ===\nfunction bondPriceInUSD() public view returns (uint256 price_) {\r\n        if (isLiquidityBond) {\r\n            price_ = bondPrice()\r\n                .mul(IBondCalculator(bondCalculator).markdown(principle))\r\n                .div(100);\r\n        } else {\r\n            price_ = bondPrice().mul(10**IERC20(principle).decimals()).div(100);\r\n        }\r\n    }\n    \n=== Functions that function bondPriceInUSD internally calls ===\nfunction bondPrice() public view returns (uint256 price_) {\r\n        price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(\r\n            1e7\r\n        );\r\n        if (price_ < terms.minimumPrice) {\r\n            price_ = terms.minimumPrice;\r\n        }\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \""SafeMath: division by zero\"");\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \""SafeMath: multiplication overflow\"");\r\n\r\n        return c;\r\n    }""","{
  ""bondPriceInUSD()"": ""function bondPriceInUSD() public view returns (uint256 price_) {\n    if (isLiquidityBond) {\n        price_ = bondPrice().mul(IBondCalculator(bondCalculator).markdown(principle)).div(100);\n    } else {\n        price_ = bondPrice().mul(10**IERC20(principle).decimals());\n    }\n}""
}"
0xa780245f9d20431bbbb537ff8d22f48d63325c73,Address,verifyCallResultFromTarget,FP,"Check for target being a contract only occurs when returndata is empty, missing in other success cases.","Tool to verify that a low level call to smart-contract was successful, and revert... if target was not a contract.","""\n=== Implementation of Function verifyCallResultFromTarget(address,bool,bytes,string) ===\nfunction verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), \""Address: call to non-contract\"");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    \n=== Functions that function verifyCallResultFromTarget internally calls ===\nfunction _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\nfunction isContract(address account) internal view returns (bool) {\n\n        return account.code.length > 0;\n    }""","{
  ""verifyCallResultFromTarget"": ""function verifyCallResultFromTarget(address target, bool success, bytes memory returndata, string memory errorMessage) internal view returns (bytes memory) {\n    if (success) {\n        require(isContract(target), \""Address: call to non-contract\"");\n        return returndata;\n    } else {\n        _revert(returndata, errorMessage);\n    }\n}""
}"
0xb03283ac8d9b1a6b198d899b8e5f9d475ba6429b,TSLN,setApprovalForAll,FP,Missing check that operator is not the caller.,- The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\n bool approved) public override onlyAllowedOperatorApproval(operator) {\n    super.setApprovalForAll(operator, approved);\n  }\n\n  function approve(address operator, uint2\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\nmodifier onlyAllowedOperatorApproval(address operator) virtual {\n        _checkFilterOperator(operator);\n        _;\n    }""","{
  ""setApprovalForAll(address,bool)"": ""function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {\n    require(operator != _msgSender(), \""Operator cannot be caller\"");\n    super.setApprovalForAll(operator, approved);\n  }""
}"
0xb3826e2db691292ecd07bbef3c2aac997cc1a390,Address,verifyCallResultFromTarget,FP,Missing contract check for successful calls with data,"Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.","""\n=== Implementation of Function verifyCallResultFromTarget(address,bool,bytes,string) ===\nfunction verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                require(isContract(target), \""Address: call to non-contract\"");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\n    \n=== Functions that function verifyCallResultFromTarget internally calls ===\nfunction _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        if (returndata.length > 0) {\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\nfunction isContract(address account) internal view returns (bool) {\r\n\r\n        return account.code.length > 0;\r\n    }""","{
  ""verifyCallResultFromTarget(address,bool,bytes,string)"": ""function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \""Address: call to non-contract\"");\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }""
}"
0xb6226ad4fef850dc8b85a83bdc0d4aff9c61cd39,JoiningFee,calc,FP,Missing scaling factor 1e18 in fee calculation.,scaling factor is 1e18,"""\n=== Implementation of Function calc(uint256,uint256,address) ===\nfunction calc(\n        uint256 firstPeriodStartTimestamp,\n        uint256 periodDuration,\n        address vault) external view returns (uint256) \n    {\n        uint256 feePerHour = hourlyJoiningFeeFor[vault];\n        if (feePerHour == 0) { \n            feePerHour = defaultHourlyJoiningFee;\n        }\n\n        uint256 numCycles = (block.timestamp - firstPeriodStartTimestamp) / periodDuration;\n        return (block.timestamp - (numCycles * periodDuration) - firstPeriodStartTimestamp) / 3600 * feePerHour;\n    }\n    ""","{
  ""calc"": ""function calc(\n        uint256 firstPeriodStartTimestamp,\n        uint256 periodDuration,\n        address vault) external view returns (uint256) \n    {\n        uint256 feePerHour = hourlyJoiningFeeFor[vault];\n        if (feePerHour == 0) { \n            feePerHour = defaultHourlyJoiningFee;\n        }\n\n        uint256 numCycles = (block.timestamp - firstPeriodStartTimestamp) / periodDuration;\n        return ((block.timestamp - (numCycles * periodDuration) - firstPeriodStartTimestamp) / 3600 * feePerHour) * 1e18;\n    }""
}"
0xd4ee885fe2e8c5c00eda1f4d91fb645c77a1de24,WeStandWithUkraine,supportsInterface,TP,Function lacks onlyOwner modifier contradicting @dev comment,@dev callable only by contract owner,"""\n=== Implementation of Function supportsInterface(bytes4) ===\nfunction supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        override(ERC721, IERC165)\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC2981).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\n    \n=== Functions that function supportsInterface internally calls ===\nfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }""","{
  ""supportsInterface(bytes4)"": ""function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) onlyOwner returns (bool) {\n        return\n            interfaceId == type(IERC2981).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }""
}"
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,ERC721,tokenURI,FN,,,,
0x141c1a97a47ae020939ab1110a954633a0bc920a,ERC20,constructor,FN,,,,
0x5cfaf9ad2cb84ce2bc40be1beb735bd12a075e99,StandardToken,decreaseApproval,FN,,,,
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,transferFrom,FN,,,,
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,safeTransferFrom,FN,,,,
0xb1259bb3a28d416a01cedc1dcc495f55c524740f,VIAINS,setActiveSale,FN,,,,
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,_transfer,FN,,,,
0x52c625b3920bb70e3a12daa2895eb0dbfebddf85,Ownable,transferOwnership,FN,,,,
