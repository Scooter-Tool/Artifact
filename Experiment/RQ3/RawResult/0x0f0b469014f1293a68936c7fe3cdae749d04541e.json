[
  {
    "contract": "ERC721A",
    "function": "transferFrom",
    "explanation": "Missing check for 'from' being zero address.",
    "violated_comment": "`from` cannot be the zero address.",
    "contract_code": "\n=== Implementation of Function transferFrom(address,address,uint256) ===\nfunction transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\n\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        assembly {\n            if approvedAddress {\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        unchecked {\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\n\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                to,\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\n            );\n\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    if (nextTokenId != _currentIndex) {\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n    \n=== Functions that function transferFrom internally calls ===\nfunction _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\nfunction _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\nfunction _getApprovedSlotAndAddress(uint256 tokenId)\n        private\n        view\n        returns (uint256 approvedAddressSlot, address approvedAddress)\n    {\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\n        assembly {\n            approvedAddressSlot := tokenApproval.slot\n            approvedAddress := sload(approvedAddressSlot)\n        }\n    }\nfunction _isSenderApprovedOrOwner(\n        address approvedAddress,\n        address owner,\n        address msgSender\n    ) private pure returns (bool result) {\n        assembly {\n            owner := and(owner, _BITMASK_ADDRESS)\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\n        }\n    }\nfunction _msgSenderERC721A() internal view virtual returns (address) {\n        return msg.sender;\n    }\nfunction _nextExtraData(\n        address from,\n        address to,\n        uint256 prevOwnershipPacked\n    ) private view returns (uint256) {\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\n    }\nfunction _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\n        assembly {\n            owner := and(owner, _BITMASK_ADDRESS)\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\n        }\n    }\nfunction _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\n        uint256 curr = tokenId;\n\n        unchecked {\n            if (_startTokenId() <= curr)\n                if (curr < _currentIndex) {\n                    uint256 packed = _packedOwnerships[curr];\n                    if (packed & _BITMASK_BURNED == 0) {\n                        while (packed == 0) {\n                            packed = _packedOwnerships[--curr];\n                        }\n                        return packed;\n                    }\n                }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\nfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }",
    "rewritten_code": {
      "transferFrom": "function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\n\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        assembly {\n            if approvedAddress {\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        unchecked {\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\n\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                to,\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\n            );\n\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    if (nextTokenId != _currentIndex) {\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }"
    }
  }
]